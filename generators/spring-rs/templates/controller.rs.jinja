{# generate controllers #}
{% import "_macros.jinja" as macros %}

{% if 'features' in values and 'rest' in values.features  -%}
{% for entity_name,entity in entities | items -%}
{% if entity.properties %}

{% set file_name = entity.title | snake_case -%}
{% set module_name = file_name | pascal_case -%}
---
to: {{ values.outputFolder }}/src/controllers/{{ file_name }}.rs
message: "Controller `{{module_name}}` was added successfully."
injections:
- into: {{ values.outputFolder }}/src/controllers/mod.rs
  append: true
  content: "pub mod {{ file_name }};"
---
use anyhow::{anyhow, Error, Context};
use spring_web::{get, post, put, delete,axum::response::{IntoResponse, Json},error::Result,extractor::{Component, Path, Query},};
use spring_sea_orm::{pagination::{Pagination, PaginationExt},DbConn, };
use serde::{Deserialize, Serialize};
use sea_orm::{ActiveModelTrait, ColumnTrait, ModelTrait, EntityTrait, QueryFilter, Set, IntoActiveModel};
{{ macros.seaorm_prelude_imports(entity) | trim }}
use crate::models::{{ file_name }}::{ActiveModel, Entity, Model, Column};
use super::utils::{ListParams,update_relation_with_diff};

{% if macros.has_one_to_many_relation(entity) or macros.has_many_to_many_relation(entity) -%}
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ResponseModel {
    {% for name, property in entity.properties | items -%}
    {%- if property.writeOnly -%}{% continue -%}{%- endif -%}
    {%- if macros.get_m2m_relation(property) or macros.relation_is_one_to_many(property)=='true' -%}
    pub {{ name | snake_case }}:Vec<i32>,
    {% elif property.type -%}
    pub {{ name | snake_case }}: {{ macros.get_type_with_option(name=name, property=property, required_fields=entity.required) }} {%- if not loop.last -%},{%- endif %}
    {% endif -%}
    {% endfor %}
}
{% endif -%}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Params {
    {% for name, property in entity.properties | items -%}
    {%- if property.readOnly-%}{% continue -%}{%- endif -%}
    {%- if macros.relation_is_many_to_many(property)=='true' -%}
    pub {{ name | snake_case }}:Vec<i32>,
    {% else -%}
    pub {{ name | snake_case }}: {{ macros.get_type_with_option(name=name, property=property, required_fields=entity.required) }} {%- if not loop.last -%},{%- endif %}
    {% endif -%}
    {% endfor %}
}

impl Params {
    fn update(&self, item: &mut ActiveModel) {
      {% for name, property in entity.properties | items -%}
        {%- if property.readOnly or macros.relation_is_many_to_many(property)=='true' -%}{% continue -%}
        {%- else -%}
      item.{{ name | snake_case }} = Set(self.{{ name | snake_case }}.clone());
        {% endif -%}
      {%- endfor -%}
    }
}

async fn load_item(db: &DbConn, id: i32) -> std::result::Result<Model, Error> {
    let item = Entity::find_by_id(id).one(db).await.context("Failed to find entity")?;
    item.ok_or_else(|| anyhow!("Entity not found"))
}

#[get("/api/{{ entity.title | plural | kebab_case  }}")]
pub async fn list(Component(db): Component<DbConn>, Query(params): Query<ListParams>, pagination: Pagination,) -> Result<impl IntoResponse> {
    let ids = params.ids.unwrap_or_default();

    let mut query = Entity::find();
    if !ids.is_empty() {
        query = query.filter(Column::Id.is_in(ids));
    }

    let users = query.page(&db, pagination).await.context("list item failed")?;
    Ok(Json(users))
}


#[post("/api/{{ entity.title | plural | kebab_case  }}")]
pub async fn insert(Component(db): Component<DbConn>, Json(params): Json<Params>) -> Result<impl IntoResponse> {
    let mut active_model = ActiveModel {
        ..Default::default()
    };
    params.update(&mut active_model);
    let model = active_model.insert(&db).await.context("failed to insert item")?;

    {% for name, property in entity.properties | items -%}
    {%- if property.readOnly-%}{% continue -%}{%- endif -%}
    {%- if macros.relation_is_many_to_many(property)=='true' -%}
    {%- set relation = macros.get_relation(property) -%}
    {% set m2m_relation_model = macros.get_m2m_relation_model(entity.title,property) | snake_case -%}
    if !params.{{ name }}.is_empty() {
            crate::models::{{ m2m_relation_model }}::Entity::insert_many(
                params.{{ name }}.clone().into_iter().map(|id| crate::models::{{ m2m_relation_model }}::ActiveModel {
                    {{ file_name }}_id: Set(model.id),
                    {{ relation | snake_case }}_id: Set(id),
                }).collect::<Vec<_>>()
            ).exec(&db).await.context(format!("failed to insert {{ name }} [{:?}] to table {{ m2m_relation_model }}", params.{{ name }}))?;
    }
    {% endif -%}
    {% endfor -%}

    Ok(Json(model))
}

#[put("/api/{{ entity.title | plural | kebab_case  }}/:id")]
pub async fn update(Component(db): Component<DbConn>, Path(id): Path<i32>, Json(params): Json<Params> ) -> Result<impl IntoResponse> {
    let item = load_item(&db, id).await?;
    let mut item = item.into_active_model();
    params.update(&mut item);
    let item = item.update(&db).await.context("failed to update item")?;

    {% for name, property in entity.properties | items -%}
    {%- if property.readOnly-%}{% continue -%}{%- endif -%}
    {%- if macros.relation_is_many_to_many(property)=='true' -%}
    {%- set relation = macros.get_relation(property) -%}
    {% set m2m_relation_model = macros.get_m2m_relation_model(entity.title,property) | snake_case -%}
    update_relation_with_diff(
        &db,
        item.id,
        params.{{ name }}.into_iter().collect(),
        crate::models::{{ m2m_relation_model }}::Entity,
        crate::models::{{ m2m_relation_model }}::Column::{{ entity.title | pascal_case }}Id,
        crate::models::{{ m2m_relation_model }}::Column::{{ relation | pascal_case }}Id,
        |{{ file_name }}_id: i32, {{ relation }}_id: i32| { crate::models::{{ m2m_relation_model }}::ActiveModel { {{ file_name }}_id: Set({{ file_name }}_id), {{ relation }}_id: Set({{ relation }}_id)}}
    ).await.context("could not update many-to-many relation {{ name }}")?;
    {% endif -%}
    {% endfor -%}

    // let new_list_ids: HashSet<i32> = params.lists.into_iter().collect();
    // update_relation_with_diff(
    //     &db,
    //     item.id,
    //     new_list_ids,
    //     crate::models::customer_list::Entity,
    //     crate::models::customer_list::Column::CustomerId,
    //     crate::models::customer_list::Column::ListId,
    //     |customer_id: i32, list_id: i32| { crate::models::customer_list::ActiveModel { customer_id: Set(customer_id), list_id: Set(list_id)}
    // }
    //
    // ).await.context("could not update many-to-many relation lists")?;

        // let existing_lists: HashSet<i32> = crate::models::customer_list::Entity::find()
        //     .filter(crate::models::customer_list::Column::CustomerId.eq(item.id))
        //     .all(&db)
        //     .await
        //     .context("could not retrieve elements of table customer_list")?
        //     .iter()
        //     .map(|e| e.list_id)
        //     .collect();
        //
        // let lists_to_insert: Vec<_> = new_list_ids.difference(&existing_lists)
        //     .map(|&list_id| crate::models::customer_list::ActiveModel {
        //         customer_id: Set(id),
        //         list_id: Set(list_id),
        //     })
        //     .collect();
        //
        // let lists_to_delete: Vec<i32> = existing_lists.difference(&existing_lists)
        //     .copied()
        //     .collect();
        // if !lists_to_insert.is_empty() {
        //     crate::models::customer_list::Entity::insert_many(lists_to_insert)
        //         .exec(&db).await.context("couldn't insert elements to table ")?;
        // }
        //
        // if !lists_to_delete.is_empty() {
        //     crate::models::customer_list::Entity::delete_many()
        //         .filter(crate::models::customer_list::Column::CustomerId.eq(id))
        //         .filter(crate::models::customer_list::Column::ListId.is_in(lists_to_delete))
        //         .exec(&db)
        //         .await.context("couldn't elements elements from table ")?;
        // }

    Ok(Json(item))
}

#[delete("/api/{{ entity.title | plural | kebab_case  }}/:id")]
pub async fn remove(Component(db): Component<DbConn>, Path(id): Path<i32>) -> Result<impl IntoResponse> {
    let item = load_item(&db, id).await?;
    item.delete(&db).await.context("failed to delete item")?;
    Ok(Json(()))
}

#[get("/api/{{ entity.title | plural | kebab_case  }}/:id")]
pub async fn fetch(Component(db): Component<DbConn>, Path(id): Path<i32>,) -> Result<impl IntoResponse> {
    let mut model = load_item(&db, id).await?;
    {% for name, property in entity.properties | items -%}
        {%- if property.readOnly-%}{% continue -%}{%- endif -%}
        {%- if macros.relation_is_many_to_many(property)=='true' -%}
        {%- set relation = macros.get_relation(property) -%}
        {% set m2m_relation_model = macros.get_m2m_relation_model(entity.title,property) | snake_case -%}
    model.{{ name }} = model.find_related(crate::models::{{ relation }}::Entity).all(&db).await.context("fetch relation {{ relation }}")?.iter().map(|item| item.id).collect::<Vec<i32>>();
        {% endif -%}
    {% endfor -%}
    Ok(Json(model))
}
---
{% endif -%}
{% endfor -%}
{% endif -%}